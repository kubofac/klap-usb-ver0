<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>KLAP_ver3 (WebUSB 10Hzå¯¾å¿œ - é€Ÿåº¦éä¾å­˜)</title>
    <link rel="manifest" href="/manifest.json">
    <style>
        html, body {
            height: 100%;
            margin: 0;
        }

        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #000000;
            color: #ffffff;
            padding: 10px;
            position: relative;
        }

        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #1c1c1e;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            padding: 20px;
            max-width: 100%;
            margin: 20px auto;
            width: 100%;
            box-sizing: border-box;
            height: 100%;
            position: relative;
        }
        
        #main-content {
            display: flex;
            width: 100%;
            gap: 20px;
            align-items: flex-start;
            justify-content: space-between;
            flex-grow: 1;
            margin-bottom: 20px;
        }

        #time-display-column {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            flex-grow: 1;
        }

        #lap-list-column {
            display: flex;
            flex-direction: column;
            width: 400px;
            flex-shrink: 0;
        }
        
        #display1 {
            font-size: 90px;
            font-weight: bold;
            color: #eeeeee;
            margin-bottom: 5px;
        }

        #display {
            font-size: 60px;
            font-weight: bold;
            color: #cccccc;
            margin-bottom: 10px;
        }

        #lap_list {
            width: 100%;
            height: 200px;
            overflow-y: auto;
            border: none;
            border-radius: 5px;
            background-color: #1c1c1e;
            padding: 10px;
        }

        #lap_list div {
            font-size: 2.5em;
            margin-bottom: 5px;
            color: #dddddd;
        }

        #buttons-row {
            display: flex;
            justify-content: space-around;
            width: 100%;
            gap: 15px;
            padding-top: 10px;
        }

        .button {
            border: 1px solid #3a3a3c;
            background-color: #2c2c2e;
            padding: 10px 15px;
            color: #ffffff;
            font-size: 16px;
            font-weight: 500;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: center;
            flex-grow: 1;
        }
        
        .button:hover { background-color: #4a4a4e; }
        #start:active { background-color: #4a804a; }
        #reset:active { background-color: #993333; }
        #lap:active { background-color: #4a4a4e; }
        
        .no-setting { background-color: #ff4d4d; }
        .no-setting:hover { background-color: #ff6666; }
        .no-setting:active { background-color: #e64444; }

        .no-gps { background-color: #ff4d4d; }
        .no-gps:hover { background-color: #ff6666; }
        .no-gps:active { background-color: #e64444; }
        
        .active-blue { background-color: #007aff; }
        .active-blue:hover { background-color: #3399ff; }
        .active-blue:active { background-color: #0066cc; }

        #debug-overlay {
            position: absolute;
            top: 0;
            left: 0;
            background-color: transparent;
            color: #ffffff;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-size: 14px;
            line-height: 1.5;
            width: 100%;
            box-sizing: border-box;
            pointer-events: none;
            opacity: 0.9;
            text-align: left;
        }
        .status-text {
            margin: 0;
        }
        #debug-overlay #debugInfo {
            margin-top: 5px;
            line-height: 1.2;
        }
        /* NMEAãƒ­ã‚°è¡¨ç¤ºã‚¨ãƒªã‚¢ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #nmeaLog {
            /* NMEAãƒ­ã‚°è¡¨ç¤ºã‚’éè¡¨ç¤º */
            display: none;
            height: 30px;
            overflow: hidden;
            border: 1px solid #ccc;
            padding: 5px;
            font-size: 10px;
            background-color: #000;
            white-space: pre;
            pointer-events: all;
            line-height: 1;
        }
        
        @media (max-width: 480px) {
            #main-content {
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }
            #time-display-column, #lap-list-column {
                width: 100%;
                align-items: center;
            }
            #buttons-row {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                width: 100%;
                align-items: center;
            }
            .button {
                width: auto;
                flex-grow: 1;
                padding: 10px 8px;
                font-size: 14px;
            }
            #display1 { font-size: 40px; }
            #display { font-size: 25px; }
            #lap_list div {
                font-size: 1.6em;
            }
            #debug-overlay {
                width: auto;
            }
            #nmeaLog {
                font-size: 8px;
            }
        }
    </style>
</head>

<body>
<div id="container">
    <div id="debug-overlay">
        <p id="status-display" class="status-text">GPSè¨­å®š: æœªå–å¾—</p>
        <div id="debugInfo" class="status-text"></div>
        <div id="nmea-raw-container" style="display: none;">
            <p class="status-text">NMEA Raw Data (Latest):</p>
            <pre id="nmeaLog">No NMEA data yet...</pre>
        </div>
    </div>
    
    <div id="main-content">
        <div id="time-display-column">
            <div id='display1'>00:00.000</div>
            <div id='display'>00:00:00.000</div>
        </div>
        <div id="lap-list-column">
            <div id='lap_list'></div>
        </div>
    </div>
    <div id="buttons-row">
        <button id="start" class="button">start</button>
        <button id="lap" class="button">lap</button>
        <button id="reset" class="button">reset</button>
        <button id="gpsButton" class="button no-gps">GPS</button>
        <button id="getSettingsBtn" class="button no-setting">GET</button>
    </div>
</div>

<script>
'use strict';
// --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
const SW_STATE = { STOP: 0, RUN: 1, PAUSE: 2 };
let swState = SW_STATE.STOP;
let startTime = 0;
let lapRecords = [];
let lapCount = 0;
let countUpTimerId = null;
let lapTimerId = null;
let lapStartTime = 0;
let isGpsRunning = false;
let lastPosition = null;
let previousSideOfLine = null;
let lastLapTime = 0;
let gpsThresholdValue = 20;
let lapCoolDown = 15000;
let isSettingsLoaded = false;
let lapFixedDisplayTimeoutId = null;
// ğŸ’¡ è¿½åŠ : å®Ÿéš›ã«åº§æ¨™FixãŒå¾—ã‚‰ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã®çŠ¶æ…‹
let hasFix = false; 

const elem = {
    display: null,
    display1: null,
    lap_list: null,
    statusDisplay: null,
    debugInfo: null,
    startButton: null,
    resetButton: null,
    lapButton: null,
    gpsButton: null,
    getSettingsBtn: null,
    nmeaLog: null,
    nmeaRawContainer: null    
};

// GPSãƒ©ãƒƒãƒ—è¨ˆæ¸¬ç”¨å¤‰æ•° - localStorageã‹ã‚‰èª­ã¿è¾¼ã‚€
let LAP_LINE_P1 = { lat: 0, lon: 0 };
let LAP_LINE_P2 = { lat: 0, lon: 0 };

// --- WebUSBé–¢é€£ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
let device = null;
let keepReading = true;
let nmeaBuffer = '';
const NMEA_VENDOR_ID = 0x1546;    
const NMEA_PRODUCT_ID = 0x01A8;    
const IN_ENDPOINT = 2;              
const INTERFACE_NUMBER = 1;

// --- æ›´æ–°ãƒ¬ãƒ¼ãƒˆ/ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºç”¨å¤‰æ•° ---
let lastUpdateTime = 0;    
let updateCounter = 0;    
let displayRateTimer = null;        
let currentUpdateRate = 0;    
let currentLat = 0.0;
let currentLon = 0.0;

// ğŸ’¡ RMCãƒ‡ãƒãƒƒã‚°ç”¨å¤‰æ•°
let latestRmcStatus = 'N/A';
let latestRmcRawLatLon = 'N/A';
let rmcUpdateCounter = 0;
let currentRmcUpdateRate = 0;

// ğŸ’¡ GGAãƒ‡ãƒãƒƒã‚°ç”¨å¤‰æ•°    
let ggaUpdateCounter = 0;
let currentGgaUpdateRate = 0;
let latestGgaStatus = 'N/A'; // Fix Quality
let latestGgaRawLatLon = 'N/A';
let latestGgaFixQuality = 0; // <--- ADDED: Fix Qualityã®æ•°å€¤ (0:No Fix, 1:GPS Fix, ...)
// ------------------------------------

// ğŸ’¡ è¿½åŠ ã™ã‚‹ãƒ‡ãƒãƒƒã‚°æƒ…å ±ç”¨ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
let latestDistance = 0.0;
let latestTimeSinceLap = 0;
let latestIsCrossing = false;


// --- ã‚¹ãƒˆãƒƒãƒ—ã‚¦ã‚©ãƒƒãƒé–¢é€£ã®é–¢æ•° ---

const totalTimePrint = (time) => {
    let h = Math.floor(time / 3600000);
    let m = Math.floor((time % 3600000) / 60000);
    let s = Math.floor((time % 60000) / 1000);
    let ms = Math.floor(time % 1000);
    
    h = ('0' + h).slice(-2);
    m = ('0' + m).slice(-2);
    s = ('0' + s).slice(-2);
    ms = ('00' + ms).slice(-3);
    
    if (elem.display) elem.display.textContent = `${h}:${m}:${s}.${ms}`;
};

const lapTimeToString = (time) => {
    let m = Math.floor(time / 60000);
    let s = Math.floor(time % 60000 / 1000);
    let ms = Math.floor(time % 1000);
    
    m = ('0' + m).slice(-2);
    s = ('0' + s).slice(-2);
    ms = ('00' + ms).slice(-3);
    
    return `${m}:${s}.${ms}`;
};

const countUp = () => {
    countUpTimerId = requestAnimationFrame(() => {
        const now = Date.now();
        const elapsedTime = now - startTime;
        totalTimePrint(elapsedTime);
        countUp();
    });
};

const startRealtimeLap = () => {
    if (swState === SW_STATE.RUN) {
        lapTimerId = requestAnimationFrame(() => {
            const now = Date.now();
            const lapElapsedTime = now - lapStartTime;
            const lapDisplay = lapTimeToString(lapElapsedTime);
            if (elem.display1) elem.display1.textContent = lapDisplay;
            startRealtimeLap();
        });
    }
};

const lapTimePrint = (time) => {          
    const lapDuration = lapTimeToString(time);
    const lapDiv = document.createElement('div');
    lapDiv.textContent = `[${lapCount}] ${lapDuration}`;      
    lapDiv.style.fontSize = '2.5em';
    if (elem.lap_list) {
        elem.lap_list.insertBefore(lapDiv, elem.lap_list.firstChild);
    }
    lapRecords.push({ count: lapCount, time: lapDuration });        
};

const updateButtonDisplay = () => {
    if (elem.lapButton) {
        elem.lapButton.style.display = (swState === SW_STATE.RUN) ? 'inline-block' : 'none';
    }
    if (elem.resetButton) {
        elem.resetButton.style.display = (swState === SW_STATE.STOP || swState === SW_STATE.PAUSE) ? 'inline-block' : 'none';
    }
    if (elem.startButton) {
        elem.startButton.textContent = (swState === SW_STATE.RUN) ? 'stop' : 'start';
    }
};

const clickStartSW = () => {
    if (!isSettingsLoaded && swState === SW_STATE.STOP) {
        if (elem.debugInfo) {
            elem.debugInfo.innerHTML = `GPSè¨­å®šãŒæœªå–å¾—ã§ã™ã€‚æ‰‹å‹•ã§ã®è¨ˆæ¸¬ã‚’é–‹å§‹ã—ã¾ã™ã€‚<br>${elem.debugInfo.innerHTML}`;
        }
    }
    
    if (swState === SW_STATE.STOP) {
        swState = SW_STATE.RUN;
        startTime = Date.now();
        lapStartTime = Date.now();
        lapCount = 0;
        elem.lap_list.innerHTML = '';
        countUp();
        startRealtimeLap();
    } else if (swState === SW_STATE.RUN) {
        swState = SW_STATE.PAUSE;
        cancelAnimationFrame(countUpTimerId);
        cancelAnimationFrame(lapTimerId);
        if (lapFixedDisplayTimeoutId) {
            clearTimeout(lapFixedDisplayTimeoutId);
        }
    } else if (swState === SW_STATE.PAUSE) {
        swState = SW_STATE.RUN;
        const now = Date.now();
        const pausedTime = now - lapStartTime;
        startTime += pausedTime;
        lapStartTime = now;
        countUp();
        startRealtimeLap();
    }
    updateButtonDisplay();
};

const clickLapSW = () => {
    if (swState === SW_STATE.RUN) {
        lapCount++;
        const now = Date.now();
        const lapDuration = now - lapStartTime;
        lapTimePrint(lapDuration);      
        lapStartTime = now;
        cancelAnimationFrame(lapTimerId);
        startRealtimeLap();
    }
};

const clickResetSW = () => {
    swState = SW_STATE.STOP;
    startTime = 0;
    lapRecords = [];
    lapCount = 0;
    cancelAnimationFrame(countUpTimerId);
    cancelAnimationFrame(lapTimerId);
    if (lapFixedDisplayTimeoutId) {
        clearTimeout(lapFixedDisplayTimeoutId);
    }
    totalTimePrint(0);
    if (elem.lap_list) elem.lap_list.innerHTML = '';
    if (elem.display1) elem.display1.textContent = '00:00.000';
    updateButtonDisplay();
    stopGps();
};

const clickGpsButton = () => {
    if (!isGpsRunning) {
        startGps();
    } else {
        stopGps();
    }
};

const getSettings = () => {
    const p1Lat = localStorage.getItem('startLineP1Lat');
    const p1Lon = localStorage.getItem('startLineP1Lon');
    const p2Lat = localStorage.getItem('startLineP2Lat');
    const p2Lon = localStorage.getItem('startLineP2Lon');
    const threshold = localStorage.getItem('gpsThreshold');
    const coolDown = localStorage.getItem('lapCoolDownTime');        

    if (p1Lat && p1Lon && p2Lat && p2Lon) {
        LAP_LINE_P1 = { lat: parseFloat(p1Lat), lon: parseFloat(p1Lon) };
        LAP_LINE_P2 = { lat: parseFloat(p2Lat), lon: parseFloat(p2Lon) };
        gpsThresholdValue = threshold ? parseFloat(threshold) : 20;
        lapCoolDown = coolDown ? parseFloat(coolDown) : 15000;        

        if (elem.statusDisplay) elem.statusDisplay.textContent = `GPSè¨­å®š: OK (é–¾å€¤: ${gpsThresholdValue}m / C/D: ${lapCoolDown / 1000}ç§’)`;
        if (elem.debugInfo) elem.debugInfo.innerHTML = "GPSè¨­å®šãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸã€‚";
        isSettingsLoaded = true;
        if (elem.getSettingsBtn) {
            elem.getSettingsBtn.classList.remove('no-setting');
            elem.getSettingsBtn.classList.add('active-blue');
        }
    } else {
        if (elem.statusDisplay) elem.statusDisplay.textContent = 'GPSè¨­å®š: æœªè¨­å®šï¼ˆè¨­å®šãƒ„ãƒ¼ãƒ«ã§ä¿å­˜ã—ã¦ãã ã•ã„ï¼‰';
        if (elem.debugInfo) elem.debugInfo.innerHTML = "localStorageã«GPSè¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚";
        isSettingsLoaded = false;
        if (elem.getSettingsBtn) {
            elem.getSettingsBtn.classList.remove('active-blue');
            elem.getSettingsBtn.classList.add('no-setting');
        }
    }
};


// ----------------------------------------------------------------------
// WebUSB/NMEA/æ›´æ–°ãƒ¬ãƒ¼ãƒˆé–¢é€£ã®é–¢æ•°    
// ----------------------------------------------------------------------

// NMEAã®DMMãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆåº¦åˆ†.åˆ†ï¼‰ã‚’10é€²æ•°ã«å¤‰æ›ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
function dmsToDecimal(dmm, direction) {
    if (!dmm) return NaN;
    
    const dotIndex = dmm.indexOf('.');
    
    if (dotIndex !== -1) {
        // NMEA DMMå½¢å¼ã§ã¯ã€ã€Œåˆ†ã€ã¯å¸¸ã«å°æ•°ç‚¹å‰ã®2æ¡ã¨å›ºå®š
        const minuteStartIndex = dotIndex - 2;
        
        if (minuteStartIndex > 0) {
            const degrees = parseInt(dmm.substring(0, minuteStartIndex));
            const minutes = parseFloat(dmm.substring(minuteStartIndex));
            
            if (isNaN(degrees) || isNaN(minutes)) return NaN;
            
            let decimal = degrees + (minutes / 60);

            if (direction === 'S' || direction === 'W') {
                decimal = -decimal;
            }
            return decimal;
        } else {
            // åº¦æ•°ãŒå­˜åœ¨ã—ãªã„ãªã©ã®ç•°å¸¸ãƒ‡ãƒ¼ã‚¿
            return NaN;
        }

    } else {
        // å°æ•°ç‚¹ãŒãªã„å ´åˆï¼ˆå¤ã„ãƒ‡ãƒ¼ã‚¿å½¢å¼ã¾ãŸã¯è§£æå¤±æ•—ãƒ‡ãƒ¼ã‚¿ï¼‰ã®å¯¾å¿œ
        const num = parseFloat(dmm);
        if (isNaN(num)) return NaN;
        
        if (dmm.length >= 4) {
            const minuteRaw = dmm.slice(-2);
            const degreeRaw = dmm.slice(0, -2);
            
            const degrees = parseInt(degreeRaw);
            const minutes = parseInt(minuteRaw);
            
            let decimal = degrees + (minutes / 60);

            if (direction === 'S' || direction === 'W') {
                decimal = -decimal;
            }
            return decimal;
        } else {
            return NaN;
        }
    }
}

/**
 * ğŸ’¡ GPSãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’Fix Qualityã«å¿œã˜ã¦æ›´æ–°ã™ã‚‹é–¢æ•°
 * @param {boolean} isFixed Fix QualityãŒ1ä»¥ä¸Šã§åº§æ¨™ãŒæœ‰åŠ¹ãªå ´åˆ true
 */
function updateGpsButtonState(isFixed) {
    if (!elem.gpsButton || !isGpsRunning) return;

    // FixçŠ¶æ…‹ãŒå¤‰åŒ–ã—ãŸå ´åˆã®ã¿å‡¦ç†ã‚’è¡Œã†
    if (hasFix !== isFixed) {
        hasFix = isFixed;
        if (isFixed) {
            // Fixã‚ã‚Š: ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ©ãƒ¼ã«å¤‰æ›´
            elem.gpsButton.classList.remove('no-fix');
            elem.gpsButton.classList.add('active-blue');
            elem.gpsButton.textContent = 'GPS (FIX)';
        } else {
            // Fixãªã—: éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ©ãƒ¼ã«å¤‰æ›´
            elem.gpsButton.classList.remove('active-blue');
            elem.gpsButton.classList.add('no-fix');
            elem.gpsButton.textContent = 'GPS (NO FIX)';
        }
    }
}


// NMEAãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è§£æã—ã€ä½ç½®æƒ…å ±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™ (GGAã‚’ä½ç½®ã®ä¸»è»¸ã€RMCã‚’é€Ÿåº¦ã®ä¸»è»¸ã¨ã™ã‚‹)
function parseNmeaLine(line) {
    const parts = line.split(',');

    // ----------------------------------------------------
    // 1. GNGGAãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç† (ä½ç½®æƒ…å ±ã®ä¾›çµ¦æº)
    // ----------------------------------------------------
    if (parts[0].toUpperCase().endsWith('GGA') && parts.length >= 7) {
        ggaUpdateCounter++;
        const fixQuality = parseInt(parts[6]);
        latestGgaFixQuality = fixQuality; // Fix Qualityã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«ä¿å­˜
        latestGgaStatus = fixQuality > 0 ? `FIX(${fixQuality})` : 'NO FIX';

        // ğŸ’¡ å¤‰æ›´ç‚¹: Fix Qualityã«å¿œã˜ã¦ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
        if (isGpsRunning) {
             updateGpsButtonState(fixQuality > 0);
        }

        // GGAãŒæœ‰åŠ¹ãªFixã‚’æŒã¤å ´åˆã€ãã®åº§æ¨™ã§ä½ç½®æƒ…å ±ã‚’æ›´æ–°ã—ã€ãƒ©ãƒƒãƒ—è¨ˆæ¸¬ãƒ­ã‚¸ãƒƒã‚¯ã«æ¸¡ã™
        if (fixQuality > 0) {
            const lat = dmsToDecimal(parts[2], parts[3]);
            const lon = dmsToDecimal(parts[4], parts[5]);

            if (!isNaN(lat) && !isNaN(lon)) {
                // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¡¨ç¤ºç”¨ã®DECåº§æ¨™ã¨RAW DMMã‚’æ›´æ–°
                currentLat = lat;
                currentLon = lon;
                const rawLat = parts.length > 2 ? `${parts[2]} ${parts[3]}` : 'N/A';
                const rawLon = parts.length > 4 ? `${parts[4]} ${parts[5]}` : 'N/A';
                latestGgaRawLatLon = `${rawLat} / ${rawLon}`;
                realTimeUpdateDebugInfo(); // GGAã§åº§æ¨™ãŒæ›´æ–°ã•ã‚ŒãŸã‚‰è¡¨ç¤ºã‚‚æ›´æ–°

                updateCounter++; // ç·ãƒ¬ãƒ¼ãƒˆã¯GGAã§ã‚«ã‚¦ãƒ³ãƒˆ

                // é€Ÿåº¦ã¯ç›´è¿‘ã®RMCã‹ã‚‰å–å¾—ã™ã‚‹ãŸã‚ã€lastPositionã®é€Ÿåº¦ã‚’ä½¿ã†
                // lastPosition.speedã«é€Ÿåº¦ãŒä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’å‰æã¨ã™ã‚‹
                const currentSpeed = (lastPosition && lastPosition.speed !== null) ? lastPosition.speed : 0;
                
                return {
                    coords: {
                        latitude: lat,
                        longitude: lon,
                        speed: currentSpeed, // RMCã‹ã‚‰å–å¾—ã—ãŸæœ€æ–°ã®é€Ÿåº¦
                        accuracy: 1
                    },
                    timestamp: Date.now()
                };
            }
        }
        return null;
    }
    
    // ----------------------------------------------------
    // 2. RMCãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç† (é€Ÿåº¦æƒ…å ±ã®ä¾›çµ¦æº)
    // ----------------------------------------------------
    else if (parts[0].toUpperCase().endsWith('RMC') && parts.length >= 8) {
        rmcUpdateCounter++;
        
        const speedKnot = parseFloat(parts[7]) || 0;
        const speedMps = speedKnot * 0.514444; 

        // ãƒ‡ãƒãƒƒã‚°æƒ…å ±æ›´æ–°
        latestRmcStatus = parts.length > 2 ? parts[2] : 'N/A';
        const rawLat = parts.length > 3 ? `${parts[3]} ${parts[4]}` : 'N/A';
        const rawLon = parts.length > 5 ? `${parts[5]} ${parts[6]}` : 'N/A';
        latestRmcRawLatLon = `${rawLat} / ${rawLon}`;

        // lastPositionã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«é€Ÿåº¦æƒ…å ±ã®ã¿ã‚’ä¿å­˜/æ›´æ–°ã™ã‚‹
        if (lastPosition) {
            lastPosition.speed = speedMps;
        } else {
             // åˆå›RMCã®å ´åˆã®åˆæœŸåŒ–
             lastPosition = {
                 lat: currentLat, // æœ€æ–°ã®GGAåº§æ¨™ï¼ˆã¾ãŸã¯å‰å›å€¤ï¼‰
                 lon: currentLon,
                 time: Date.now(),
                 speed: speedMps 
             };
        }

        // RMCã¯ä½ç½®æƒ…å ±ã‚’æä¾›ã—ãªã„ãŸã‚ã€ã“ã“ã§ã¯nullã‚’è¿”ã™
        return null;
    }

    return null;
}

// NMEAãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒãƒƒãƒ•ã‚¡ã‚’ç®¡ç†ã—ã€è¡Œã”ã¨ã«ãƒ‘ãƒ¼ã‚µãƒ¼ã«æ¸¡ã™
function processNmeaData(data) {
    nmeaBuffer += data;
    let newlineIndex;

    while ((newlineIndex = nmeaBuffer.indexOf('\n')) !== -1) {
        const line = nmeaBuffer.substring(0, newlineIndex).trim();
        nmeaBuffer = nmeaBuffer.substring(newlineIndex + 1);

        if (line.startsWith('$') && line.length > 5) {
            const position = parseNmeaLine(line);
            
            if (position && swState === SW_STATE.RUN) {
                onWebUsbPositionUpdate(position);
            }
        }
    }
}

// 1ç§’ã”ã¨ã«æ›´æ–°ãƒ¬ãƒ¼ãƒˆã‚’è¨ˆç®—ã—ã¦è¡¨ç¤ºã™ã‚‹ã‚¿ã‚¤ãƒãƒ¼ã‚’é–‹å§‹
function startRateMeasurement() {
    if (displayRateTimer !== null) {
        clearInterval(displayRateTimer);
        displayRateTimer = null;
    }
    
    currentUpdateRate = 0;
    updateCounter = 0;    
    currentRmcUpdateRate = 0;
    rmcUpdateCounter = 0;
    currentGgaUpdateRate = 0;
    ggaUpdateCounter = 0;    
    
    displayRateTimer = setInterval(() => {
        currentUpdateRate = updateCounter;    
        updateCounter = 0;    
        
        currentRmcUpdateRate = rmcUpdateCounter;
        rmcUpdateCounter = 0;    
        
        currentGgaUpdateRate = ggaUpdateCounter;
        ggaUpdateCounter = 0;    
        
        updateDebugDisplay();    
    }, 1000);    
}

// æ›´æ–°ãƒ¬ãƒ¼ãƒˆã®è¨ˆæ¸¬ã‚’åœæ­¢
function stopRateMeasurement() {
    if (displayRateTimer !== null) {
        clearInterval(displayRateTimer);
        displayRateTimer = null;    
    }
    currentUpdateRate = 0;
    currentRmcUpdateRate = 0;    
    currentGgaUpdateRate = 0;
}

// ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§æ›´æ–°ã•ã‚Œã‚‹ãƒ‡ãƒãƒƒã‚°æƒ…å ± (GGA RAW DMM, DECè¡¨ç¤º)    
function realTimeUpdateDebugInfo() {
    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±å…¨ä½“ãŒéè¡¨ç¤ºã§ãªã„ã“ã¨ã‚’ç¢ºèª
    if (elem.debugInfo && elem.debugInfo.parentElement.style.display !== 'none') {
        const ggaRawDmmDisplay = document.getElementById('ggaRawDmmDisplay');
        if (ggaRawDmmDisplay) {
            ggaRawDmmDisplay.textContent = `GGA RAW DMM: ${latestGgaRawLatLon}`;
        }

        const decLatLonDisplay = document.getElementById('decLatLonDisplay');
        if (decLatLonDisplay) {
            decLatLonDisplay.textContent = `DEC: ${currentLat.toFixed(6)} / ${currentLon.toFixed(6)}`;
        }
    }
}


// ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
function updateDebugDisplay() {
    if (!elem.debugInfo) return;
    
    // ğŸ’¡ æ—¢å­˜ã®ãƒ‡ãƒãƒƒã‚°æƒ…å ±
    const rateText = `ç·ãƒ¬ãƒ¼ãƒˆ: ${currentUpdateRate.toFixed(0)} Hz | RMCãƒ¬ãƒ¼ãƒˆ: ${currentRmcUpdateRate.toFixed(0)} Hz | GGAãƒ¬ãƒ¼ãƒˆ: ${currentGgaUpdateRate.toFixed(0)} Hz`;
    const rmcStatusText = `RMC Status: ${latestRmcStatus}`;
    const ggaStatusText = `GGA Status: ${latestGgaStatus}`;
    const latLonText = `<span id="decLatLonDisplay">DEC: ${currentLat.toFixed(6)} / ${currentLon.toFixed(6)}</span>`;    
    const rmcRawText = `RMC RAW DMM: ${latestRmcRawLatLon}`;
    // lastPosition.speedã‚’å‚ç…§ã™ã‚‹ã‚ˆã†ã«ä¿®æ­£
    const speedText = `é€Ÿåº¦: ${(lastPosition && lastPosition.speed !== null) ? lastPosition.speed.toFixed(2) : 'N/A'} m/s`;
    const lapCountText = `å‘¨å›æ•°: ${lapCount}`;    
    
    // ğŸ’¡ è¿½åŠ ã™ã‚‹ãƒ‡ãƒãƒƒã‚°æƒ…å ±
    const distanceText = `è·é›¢: ${latestDistance.toFixed(2)} m`;
    const timeSinceLapText = `å‰å›ã‹ã‚‰ã®çµŒéæ™‚é–“: ${(latestTimeSinceLap / 1000).toFixed(2)}ç§’`;
    const crossingText = `ãƒ©ã‚¤ãƒ³é€šé: ${latestIsCrossing}`;


    elem.debugInfo.innerHTML = `
        ${rateText}<br>
        ${rmcStatusText} | ${ggaStatusText}<br>
        ${latLonText}<br>
        ${rmcRawText}<br>
        <span id="ggaRawDmmDisplay">GGA RAW DMM: ${latestGgaRawLatLon}</span><br>
        ${speedText} | ${lapCountText}<br>
        ${distanceText} | ${timeSinceLapText} | ${crossingText}
    `;
    
    const statusColor = (latestRmcStatus === 'A' || latestGgaStatus.startsWith('FIX')) ? 'lime' : 'white';
    elem.debugInfo.style.color = statusColor;
    
    // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¡¨ç¤ºã®æ›´æ–°ã¯ parseNmeaLine ã§å‘¼ã³å‡ºã•ã‚Œã‚‹ realTimeUpdateDebugInfo() ã«ä»»ã›ã‚‹
    // realTimeUpdateDebugInfo();
}

// WebUSBãƒ‡ãƒ¼ã‚¿èª­ã¿å–ã‚Šãƒ«ãƒ¼ãƒ—
async function readLoop() {
    const nmeaLogElement = elem.nmeaLog;    
    
    while (device && keepReading) {
        try {
            const result = await device.transferIn(IN_ENDPOINT, 512);    
            if (result.status === 'ok' && result.data) {
                const decoder = new TextDecoder('iso-8859-1');
                const nmeaData = decoder.decode(result.data);
                
                if (nmeaLogElement && nmeaData.length > 0) {
                    // NMEAãƒ­ã‚°è¡¨ç¤ºãŒéè¡¨ç¤º
                    if (nmeaLogElement.style.display !== 'none') {
                        const lines = nmeaData.trim().split('\n');
                        if (lines.length > 0) {
                            const latestLine = lines[lines.length - 1].trim();    
                            nmeaLogElement.textContent = latestLine;    
                        }
                    }
                }
                
                processNmeaData(nmeaData);    
            }
        } catch (error) {
            if (keepReading) {
                if (elem.debugInfo) elem.debugInfo.innerHTML = `USBèª­ã¿å–ã‚Šã‚¨ãƒ©ãƒ¼: ${error.message}`;
            }
            break;    
        }
    }
}

// WebUSBæ¥ç¶šã‚’é–‹å§‹
async function startWebUsbGps() {
    try {
        if (!elem.gpsButton) return;
        
        // æ¥ç¶šè©¦è¡Œä¸­ã®è¡¨ç¤ºã¨ã‚¹ã‚¿ã‚¤ãƒ«ã®å¤‰æ›´
        if (elem.statusDisplay) elem.statusDisplay.textContent = 'USBãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œç´¢ä¸­...';
        elem.gpsButton.textContent = 'æ¥ç¶šä¸­...';    
        elem.gpsButton.disabled = true; 
        elem.gpsButton.classList.remove('active-blue', 'no-fix', 'no-gps'); // no-fixã‚’è¿½åŠ 
        elem.gpsButton.classList.add('connecting'); 
        

        device = await navigator.usb.requestDevice({
            filters: [{ vendorId: NMEA_VENDOR_ID, productId: NMEA_PRODUCT_ID }]
        });
        
        await device.open();
        
        if (device.configuration === null) {
            await device.selectConfiguration(device.configurations[0].configurationValue);
        }
        
        await device.claimInterface(INTERFACE_NUMBER);
        
        // æ¥ç¶šæˆåŠŸæ™‚ï¼ˆã“ã®æ™‚ç‚¹ã§ã¯ã¾ã FixãŒå¾—ã‚‰ã‚Œã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§NO FIX/æ¥ç¶šä¸­ã®è‰²ã«ã™ã‚‹ï¼‰
        if (elem.statusDisplay) elem.statusDisplay.textContent = 'GPSãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ¥ç¶šå®Œäº†ã€‚ãƒ‡ãƒ¼ã‚¿ç›£è¦–ä¸­...';
        elem.gpsButton.textContent = 'GPS (å¾…æ©Ÿ)';
        elem.gpsButton.classList.remove('no-gps', 'connecting');
        elem.gpsButton.classList.add('no-fix'); // æ¥ç¶šå®Œäº†ã—ãŸãŒFixãªã—ã®è‰² (no-fixã‚¯ãƒ©ã‚¹ã‚’åˆ¥é€”CSSã§å®šç¾©ã—ã¦ãã ã•ã„)
        elem.gpsButton.disabled = false; 
        isGpsRunning = true;
        keepReading = true;
        
        startRateMeasurement();    
        readLoop();    
        
    } catch (error) {
        if (elem.debugInfo) elem.debugInfo.innerHTML = `USBæ¥ç¶šã‚¨ãƒ©ãƒ¼: ${error.message}`;
        stopGps(); // ã‚¨ãƒ©ãƒ¼æ™‚ã¯åœæ­¢å‡¦ç†ã‚’å‘¼ã³å‡ºã™
    }
}

// GPSç›£è¦–ã‚’é–‹å§‹ã™ã‚‹
function startGps() {
    if (!isSettingsLoaded) {
        if (elem.debugInfo) elem.debugInfo.innerHTML = "GPSè¨­å®šãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚<br>GETãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦è¨­å®šã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„ã€‚";
        return;
    }
    startWebUsbGps();
}

// GPSç›£è¦–ã‚’åœæ­¢ã™ã‚‹
async function stopGps() {
    stopRateMeasurement();    

    keepReading = false;
    if (device) {
        try {
            await device.releaseInterface(INTERFACE_NUMBER);
            await device.close();
        } catch (error) {
            // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
        }
        device = null;
    }
    isGpsRunning = false;
    hasFix = false; // çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
    if (elem.statusDisplay) elem.statusDisplay.textContent = 'GPSç›£è¦–åœæ­¢';
    
    // åœæ­¢æ™‚ã®è¡¨ç¤ºã¨ã‚¹ã‚¿ã‚¤ãƒ«ã®ãƒªã‚»ãƒƒãƒˆ
    if (elem.gpsButton) {
        elem.gpsButton.textContent = 'GPS';
        elem.gpsButton.classList.remove('active-blue', 'connecting', 'no-fix'); 
        elem.gpsButton.classList.add('no-gps'); // åˆæœŸçŠ¶æ…‹ã«æˆ»ã™
        elem.gpsButton.disabled = false; 
    }
    
    if(elem.nmeaLog) elem.nmeaLog.textContent = 'No NMEA data yet...';
    currentLat = 0.0;
    currentLon = 0.0;
    latestRmcStatus = 'N/A';
    latestRmcRawLatLon = 'N/A';
    latestGgaStatus = 'N/A';
    latestGgaRawLatLon = 'N/A';
    latestGgaFixQuality = 0; 
    lastPosition = null;
    
    // åœæ­¢æ™‚ã«ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’ãƒªã‚»ãƒƒãƒˆ
    latestDistance = 0.0;
    latestTimeSinceLap = 0;
    latestIsCrossing = false;
    updateDebugDisplay();
}

// WebUSBã‹ã‚‰ã®ä½ç½®æƒ…å ±æ›´æ–°å‡¦ç†ï¼ˆãƒ©ãƒƒãƒ—è¨ˆæ¸¬ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
function onWebUsbPositionUpdate(position) {
    if (swState !== SW_STATE.RUN || !isGpsRunning) {
        return;
    }
    
    lastUpdateTime = Date.now();
    
    const currentLat = position.coords.latitude;
    const currentLon = position.coords.longitude;
    const currentTime = Date.now();
    
    // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ç¾¤
    const calculateDistance = (lat1, lon1, lat2, lon2) => {
        const R = 6371e3;
        const Ï†1 = lat1 * Math.PI / 180;
        const Ï†2 = lat2 * Math.PI / 180;
        const Î”Ï† = (lat2 - lat1) * Math.PI / 180;
        const Î”Î» = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) + Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    };
    
    const calculatePerpendicularFootApprox = (lineLat1, lineLon1, lineLat2, lineLon2, pointLat, pointLon) => {
        const dx = lineLon2 - lineLon1;
        const dy = lineLat2 - lineLat1;
        const lineLenSq = dx * dx + dy * dy;
        if (lineLenSq < 1e-9) return { latitude: lineLat1, longitude: lineLon1 };
        const t = ((pointLon - lineLon1) * dx + (pointLat - lineLat1) * dy) / lineLenSq;
        if (t < 0) return { latitude: lineLat1, longitude: lineLon1 };
        if (t > 1) return { latitude: lineLat2, longitude: lineLon2 };
        return { latitude: lineLat1 + t * dy, longitude: lineLon1 + t * dx };
    };
    
    const getSideOfLine = (pointLat, pointLon, lineLat1, lineLon1, lineLat2, lineLon2) => {
        return (lineLon2 - lineLon1) * (pointLat - lineLat1) - (lineLat2 - lineLat1) * (pointLon - lineLon1);
    };

    const getIntersectionTime = (p1, p2) => {
        // p1(lat, lon, time), p2(lat, lon, time)
        
        // åˆ†æ¯
        const den = (LAP_LINE_P2.lon - LAP_LINE_P1.lon) * (p2.lat - p1.lat) - (LAP_LINE_P2.lat - LAP_LINE_P1.lat) * (p2.lon - p1.lon);
        if (Math.abs(den) < 1e-9) return null;
        
        // P1->P2é–“ã®äº¤å·®æ¯”ç‡ t_ratio ã®åˆ†å­
        const t_num = (LAP_LINE_P2.lon - LAP_LINE_P1.lon) * (LAP_LINE_P1.lat - p1.lat) - (LAP_LINE_P2.lat - LAP_LINE_P1.lat) * (LAP_LINE_P1.lon - p1.lon);
        const t_ratio = t_num / den;

        if (t_ratio < 0 || t_ratio > 1) return null; // P1-P2ã®ç·šåˆ†ã®å¤–å´ã§äº¤å·®
        
        // ã‚¹ã‚¿ãƒ¼ãƒˆãƒ©ã‚¤ãƒ³ã®ç·šåˆ†ã®ç¯„å›²ãƒã‚§ãƒƒã‚¯ (u)
        const u_num = (LAP_LINE_P1.lat - p1.lat) * (p2.lon - p1.lon) - (LAP_LINE_P1.lon - p1.lon) * (p2.lat - p1.lat);
        const u = u_num / den;
        if (u < 0 || u > 1) return null; // ã‚¹ã‚¿ãƒ¼ãƒˆãƒ©ã‚¤ãƒ³ã®ç·šåˆ†ã®å¤–å´

        // æ¯”ç‡ã‚’ä½¿ã£ã¦æ™‚é–“ã‚’è£œé–“
        return p1.time + (p2.time - p1.time) * t_ratio;
    };
    // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ç¾¤ã“ã“ã¾ã§

    if (!lastPosition) {
        lastPosition = {    
            lat: currentLat,    
            lon: currentLon,    
            time: currentTime,    
            speed: position.coords.speed || 0    
        };    
        previousSideOfLine = getSideOfLine(currentLat, currentLon, LAP_LINE_P1.lat, LAP_LINE_P1.lon, LAP_LINE_P2.lat, LAP_LINE_P2.lon);
        
        // ğŸ’¡ åˆæœŸå€¤è¨­å®š
        const P = calculatePerpendicularFootApprox(LAP_LINE_P1.lat, LAP_LINE_P1.lon, LAP_LINE_P2.lat, LAP_LINE_P2.lon, currentLat, currentLon);
        latestDistance = calculateDistance(currentLat, currentLon, P.latitude, P.longitude);
        latestTimeSinceLap = currentTime - lastLapTime;
        latestIsCrossing = false;
        
        return;
    }

    // lastPositionã®ç·¯åº¦/çµŒåº¦/æ™‚åˆ»ã‚’ä¸€æ™‚çš„ã«å¤‰æ•°ã«ä¿å­˜
    const P1_lat = lastPosition.lat;
    const P1_lon = lastPosition.lon;
    const P1_time = lastPosition.time;


    const currentSideOfLine = getSideOfLine(currentLat, currentLon, LAP_LINE_P1.lat, LAP_LINE_P1.lon, LAP_LINE_P2.lat, LAP_LINE_P2.lon);
    const isCrossingLine = (previousSideOfLine > 0 && currentSideOfLine < 0) || (previousSideOfLine < 0 && currentSideOfLine > 0);
    const timeSinceLastLap = currentTime - lastLapTime;
    const isCoolDownOver = (lapCount === 0) || (timeSinceLastLap >= lapCoolDown);

    const P = calculatePerpendicularFootApprox(LAP_LINE_P1.lat, LAP_LINE_P1.lon, LAP_LINE_P2.lat, LAP_LINE_P2.lon, currentLat, currentLon);
    const distanceToStartLine = calculateDistance(currentLat, currentLon, P.latitude, P.longitude);
    const isNearStartLine = distanceToStartLine <= gpsThresholdValue;

    // ğŸ’¡ ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’æ›´æ–°
    latestDistance = distanceToStartLine;
    latestTimeSinceLap = timeSinceLastLap;
    latestIsCrossing = isCrossingLine;
    

    if (isCrossingLine && isCoolDownOver && isNearStartLine) {
        
        // é€Ÿåº¦ã«ä¾å­˜ã—ãªã„ã€ç´”ç²‹ãªç›´ç·šè£œé–“ç”¨ã®ä½ç½®ãƒ‡ãƒ¼ã‚¿
        const P1_for_Intersection = {    
            lat: P1_lat,    
            lon: P1_lon,    
            time: P1_time    
        };
        const P2_for_Intersection = {    
            lat: currentLat,    
            lon: currentLon,    
            time: currentTime    
        };

        // P1ã¨P2ã‚’çµã¶ç·šåˆ†ã¨ã€ã‚¹ã‚¿ãƒ¼ãƒˆãƒ©ã‚¤ãƒ³ã®äº¤å·®æ™‚åˆ»ã‚’æ¨å®š
        const intersectionTime = getIntersectionTime(P1_for_Intersection, P2_for_Intersection);
        
        if (intersectionTime !== null) {
            
            // è£œé–“ã•ã‚ŒãŸæ­£ç¢ºãªäº¤å·®æ™‚åˆ»ã‚’ç”¨ã„ã¦ãƒ©ãƒƒãƒ—ã‚¿ã‚¤ãƒ ã‚’è¨ˆç®—
            const lapDuration = intersectionTime - lapStartTime;
            
            // ãƒ©ãƒƒãƒ—ã‚¿ã‚¤ãƒ ã‚’è¨˜éŒ²
            lapCount++;
            lapTimePrint(lapDuration); // ãƒ©ãƒƒãƒ—ãƒªã‚¹ãƒˆã«è¨˜éŒ²
            
            // æ¬¡ã®ãƒ©ãƒƒãƒ—ã®ã‚¹ã‚¿ãƒ¼ãƒˆæ™‚é–“ã‚’äº¤å·®æ™‚åˆ»ã«è¨­å®š
            lapStartTime = intersectionTime;
            lastLapTime = intersectionTime; // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³åˆ¤å®šç”¨
            
            // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ©ãƒƒãƒ—è¡¨ç¤ºã‚’ä¸€æ™‚åœæ­¢
            cancelAnimationFrame(lapTimerId);
            
            // ãƒ¡ã‚¤ãƒ³ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ã«ç¢ºå®šãƒ©ãƒƒãƒ—ã‚¿ã‚¤ãƒ ã‚’å›ºå®šè¡¨ç¤º
            if (elem.display1) elem.display1.textContent = lapTimeToString(lapDuration);
            
            // 2ç§’å¾Œã«ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¨ˆæ¸¬ã‚’å†é–‹
            if (lapFixedDisplayTimeoutId) {
                clearTimeout(lapFixedDisplayTimeoutId);
            }
            lapFixedDisplayTimeoutId = setTimeout(() => {
                // RUNçŠ¶æ…‹ã§ã‚ã‚Œã°æ¬¡ã®ãƒ©ãƒƒãƒ—ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¨ˆæ¸¬ã‚’é–‹å§‹
                if (swState === SW_STATE.RUN) {
                    startRealtimeLap();    
                }
            }, 2000);    

            // ãƒ©ãƒƒãƒ—å¾Œã®ä½ç½®æƒ…å ±ã‚’æ›´æ–° (lastPosition.speedã¯RMCå‡¦ç†ã§æ—¢ã«æ›´æ–°ã•ã‚Œã¦ã„ã‚‹)
            previousSideOfLine = currentSideOfLine;
            lastPosition.lat = currentLat;
            lastPosition.lon = currentLon;
            lastPosition.time = currentTime;
            
        } else {
            // äº¤å·®æ™‚åˆ»ãŒè¨ˆç®—ã§ããªã‹ã£ãŸå ´åˆï¼ˆç¨€ãªã‚±ãƒ¼ã‚¹ï¼‰ã€ç¾åœ¨ã®ã‚µã‚¤ãƒ‰ã¨ä½ç½®æƒ…å ±ã‚’æ›´æ–°
            previousSideOfLine = currentSideOfLine;
            lastPosition.lat = currentLat;
            lastPosition.lon = currentLon;
            lastPosition.time = currentTime;
            // lastPosition.speedã¯RMCå‡¦ç†ã§æ›´æ–°æ¸ˆã¿
        }
    } else {
        // ãƒ©ã‚¤ãƒ³ã‚’æ¨ªåˆ‡ã‚‰ãªã‹ã£ãŸã€ã¾ãŸã¯ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æœŸé–“ä¸­ã®å ´åˆã€ä½ç½®æƒ…å ±ã‚’æ›´æ–°
        previousSideOfLine = currentSideOfLine;
        lastPosition.lat = currentLat;
        lastPosition.lon = currentLon;
        lastPosition.time = currentTime;
        // lastPosition.speedã¯RMCå‡¦ç†ã§æ›´æ–°æ¸ˆã¿
    }
    
    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚‚å¸¸ã«æœ€æ–°ã®ä½ç½®æƒ…å ±ã«åŸºã¥ã„ã¦æ›´æ–°
    updateDebugDisplay();
}


// --- åˆæœŸåŒ–å‡¦ç† ---
window.onload = () => {
    // ç”»é¢è¦ç´ ã®å–å¾—
    elem.display = document.getElementById('display');
    elem.display1 = document.getElementById('display1');
    elem.lap_list = document.getElementById('lap_list');
    elem.statusDisplay = document.getElementById('status-display');
    elem.debugInfo = document.getElementById('debugInfo');
    elem.startButton = document.getElementById('start');
    elem.resetButton = document.getElementById('reset');
    elem.lapButton = document.getElementById('lap');
    elem.gpsButton = document.getElementById('gpsButton');
    elem.getSettingsBtn = document.getElementById('getSettingsBtn');
    elem.nmeaLog = document.getElementById('nmeaLog');
    elem.nmeaRawContainer = document.getElementById('nmea-raw-container');

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
    if (elem.startButton) elem.startButton.addEventListener('click', clickStartSW);
    if (elem.resetButton) elem.resetButton.addEventListener('click', clickResetSW);
    if (elem.lapButton) elem.lapButton.addEventListener('click', clickLapSW);
    if (elem.gpsButton) elem.gpsButton.addEventListener('click', clickGpsButton);
    if (elem.getSettingsBtn) elem.getSettingsBtn.addEventListener('click', getSettings);
    
    // WebUSBå¯¾å¿œãƒã‚§ãƒƒã‚¯
    if (!navigator.usb) {
        if (elem.statusDisplay) elem.statusDisplay.textContent = 'ã‚¨ãƒ©ãƒ¼: WebUSBéå¯¾å¿œãƒ–ãƒ©ã‚¦ã‚¶ã§ã™ã€‚';
        if (elem.gpsButton) elem.gpsButton.disabled = true;
        if (elem.gpsButton) {
            elem.gpsButton.classList.remove('active-blue', 'connecting', 'no-fix');
            elem.gpsButton.classList.add('no-gps');
        }
    }
    
    // åˆå›è¡¨ç¤ºã®æ›´æ–°ã¨è¨­å®šã®èª­ã¿è¾¼ã¿
    updateButtonDisplay();
    getSettings();
    updateDebugDisplay();
    
    // GPSãƒœã‚¿ãƒ³ã®åˆæœŸçŠ¶æ…‹è¨­å®š
    if (navigator.usb && elem.gpsButton) {
        if (!isGpsRunning) {
             elem.gpsButton.classList.remove('active-blue', 'connecting', 'no-fix');
             elem.gpsButton.classList.add('no-gps');
        }
    }
};

</script>
</body>
</html>



